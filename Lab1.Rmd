---
title: "Computer Lab 1"
author: "Martynas Lukosevicius, Alejo Perez Gomez, Zahra Jalil Pour"
date: "03/11/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question 1 (Be Careful When Comparing)

### 1 
It is not possible to represent exact 1/3 and 1/12 in binary. As a result it is rounded towards nearest computer float and in R its equal to 0.33333333333333331 and 0.083333333333333329 respectively.
In the first snippet code, the result is "Subtraction is wrong", but the second snippet code the result is "Subtraction is correct". 
The only numbers that represent exactly in r , are integers and fractions by power of 2 denominator. Hence all other numbers are rounded to 53 binary digits accuracy. When ever floating point operations are done , we should assume that there will be  numeric error. 1/3 and 1/12 are repeating decimals that are rounded in R.

### 2

Instead of writing  ``if(x1 - x2 == 1/12)`` it should be written ``if(isTRUE(all.equal(x1-x2,1/12)))``. In this case this equation will return TRUE.
We can use ``all.equal`` function , or we can use ``all.equal.numeric`` function too.
```{r echo = FALSE, warning=FALSE, include=FALSE}
#1.2
# all.equal.numeric() and isTRUE() function
x1 <- 1/3
x2 <- 1/4
if (isTRUE(all.equal.numeric(x1-x2, 1/12))) {
  print ("Subtraction is correct" )
} else {
  print ("Subtraction is wrong")
}
```

## Question 2 (Derivative)
###1

Write your own R function to calculate the derivative of ``f(x) = x`` in this way with ``e = 10^-15``.
```{r}
deriv <- function(x){
  e <- 10^(-15)
  derivative <- ((x+e)-x)/e
  return(derivative)
}

```
###2
Evaluate your derivative function at ``x = 1`` and ``x = 100000``
```{r}
deriv(1)
```

[1] 1.110223

```{r}
deriv(100000)
```
[1] 0

###3
What values did you obtain? What are the true values? Explain the reasons behind the
discovered differences.
The smallest positive computer number is epsilon that here we considered it ``10^(-15)``When ``x=100000`` the derivative function showed 0, in equation``((x+e)-x)`` , difference between large numbers dominates epsilon, in other words the smallest positive number is added to the large number. Hence the epsilon would be ignored. But when `` x=1``, the effect of epsilon can not be ignored the result would be 1.110223.  

## Question 4

### 1

is it he case when n = k = 0 or n > 0, k = 0 ?

```{r}
n <- 1000
k <- 800
prod(1:n) / (prod(1:k) * prod(1:(n-k)))
prod((k+1):n) / prod(1:(n-k))
prod(((k+1):n) / (1:(n-k)))
```


### 2
```{r, echo=FALSE,  fig.height= 6}
#n <- c(20:100)

calc1 <- function(n,k){
k <- n - k
 return(prod(1:n) / (prod(1:k) * prod(1:(n-k)))) 
}
calc2 <- function(n,k){
  k <- n - k
 return(prod((k+1):n) / prod(1:(n-k))) 
}
calc3 <- function(n,k){
  k <- n - k
 return(prod(((k+1):n) / (1:(n-k)))) 
}

n <- c(20:400)
k <- 20

y <-  sapply(n, calc1, k = k)
y2 <-  sapply(n, calc2, k = k)
y3 <-  sapply(n, calc3, k = k)
par(mfrow=c(3,1))
plot(n,y, type = "l", main = "A , k =n-20" , ylab = "y")
plot(n,y2, type = "l", main = "B , k =n-20", ylab = "y")
plot(n, y3, type = "l", main = "C , k =n-20", ylab = "y")
```


```{r, echo=FALSE,  fig.height= 6}
calc1 <- function(n,k){
 return(prod(1:n) / (prod(1:k) * prod(1:(n-k)))) 
}
calc2 <- function(n,k){
 return(prod((k+1):n) / prod(1:(n-k))) 
}
calc3 <- function(n,k){
 return(prod(((k+1):n) / (1:(n-k)))) 
}

n <- c(20:400)
k <- 20

y <-  sapply(n, calc1, k = k)
y2 <-  sapply(n, calc2, k = k)
y3 <-  sapply(n, calc3, k = k)
par(mfrow=c(3,1))

plot(n,y, type = "l", main = "k =n-20", sub =  "A  " , ylab = "y")
plot(n,y2, type = "l", sub = "B , k =n-20", ylab = "y")
plot(n, y3, type = "l", sub = "C , k =n-20", ylab = "y")

```

### 3
expression A and B, because with large numbers method prod() will overflow. 

In expression A we calculate product of vector from 1 to n and later divide it by other products with smaller vectors. However in this case first operation (prod(1:n)) will overflow ( = Inf) and other operations wont matter as the result will be Inf or Nan (if denominator will be also Inf).

In expression B overflow will depend on k, if k is close to n it wont overflow.

In expression C, as first vectors are divided, the final vector for product will have smaller values and that is why prod() method wont overflow.

